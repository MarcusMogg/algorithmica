
交错执行是数电中的通用概念，不仅应用于 主CPU 流水线，还应用于单独的指令和内存。需要执行单元有它们自己的小流水线，可以在前一个指令之后一两个周期内接受另一条指令。

在这个上下文中，指令使用两个不同的”代价“是有意义的

- *Latency* 延迟: 接受指令结果需要多少个周期.
- *Throughput*吞吐量: 平均每个周期可以执行多少指令。

你可以从一个叫做 指令表 [instruction tables](https://www.agner.org/optimize/instruction_tables.pdf) 的特殊文档中 找到特定架构的指令延迟和吞吐。 下面是我的Zen2 的一些值

| Instruction | Latency | RThroughput |
|-------------|---------|:------------|
| `jmp`       | -       | 2           |
| `mov r, r`  | -       | 1/4         |
| `mov r, m`  | 4       | 1/2         |
| `mov m, r`  | 3       | 1           |
| `add`       | 1       | 1/3         |
| `cmp`       | 1       | 1/4         |
| `popcnt`    | 1       | 1/4         |
| `mul`       | 3       | 1           |
| `div`       | 13-28   | 13-28       |

一些评论:

- 因为我们的观念中 费用模型是 ”多“意味着 ”差“，所以人们使用吞吐量的 *倒数* 而不是吞吐量
- 如果一个指令使用更频繁，那么复制它的执行单元 来增加吞吐量，但不超过decode width
- 一些指令的延迟是0.这意味着 这些指令是用于控制调度器，并不会到执行阶段。它们的吞吐量倒数不为0，这意味着CPU前端任然需要处理它们。
- 大部分指令是 流水线处理的，如果它们的吞吐量倒数为n，那通常意味着 它们的执行单元需要n个周期后才能接受下一个请求（如果小于1，那么意味这有多个执行单元，它们都可以在下个周期接受另一个指令）。 一个值得注意的例外是 整数除法，它要么流水线非常差，要么根本没有流水线。
- 一些指令有可变 延迟，不仅取决于大小，还取决于操作数的个数。对于内存操作（包括融合操作 比如`add`）, 延迟通常指定为最佳情况（L1 缓存命中）。

还有很多更重要的小细节，但这个心智模型现在就足够了。a
