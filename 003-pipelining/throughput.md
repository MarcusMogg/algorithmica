

优化*latency* 通常和 优化*throughput* 非常不同：

- 当优化数据结构查询、小型一次性 或者分支算法时，你需要查找 指令的延迟，在心中构建计算的执行图，然后尝试对其进行重组以缩短关键路径长度。
- 在优化热循环或者大数据集算法时，你需要查找指令的吞吐量，计算每次迭代花费多少时间，确定其中那些是瓶颈，然后尝试重新组织循环，以减少它的耗时。

后一个建议仅在数据并行 循环上有效，每一个迭代和之前是完全无关的。当连续的迭代之间存在关联性，会出现很多 data hazard 导致的流水线停顿，下一代迭代需要等待之前的完全完成
## 例子

一个简单的例子，计算数组和

```c++
int s = 0;

for (int i = 0; i < n; i++)
    s += a[i];
```

让我们假设编译器没有向量化循环，内存带宽不需要考虑，循环已经被展开所以我们不需要额外花费在循环变量上。这样，计算可以变得十分简单：

```c++
int s = 0;
s += a[0];
s += a[1];
s += a[2];
s += a[3];
// ...
```

现在计算多快？ 实际上每个周期一个元素，因为我们每个迭代需要花费一个周期 `add` 另一个值到`s`中。 内存读取的延迟并不重要，因为CPU可以提取执行。

但是我们可以更快。在我的CPU上 `add` 的吞吐量是2，这意味着我们可以每个周期执行两个加法。 但现在是不可能的，因为当s用于第i个元素，至少一个周期内它不能用在第 i+1个元素 

解决方案是使用两个值 ，分别计算偶数和奇数的和

```c++
int s0 = 0, s1 = 0;
s0 += a[0];
s1 += a[1];
s0 += a[2];
s1 += a[3];
// ...
int s = s0 + s1;
```


现在我们的超标量处理器可以同时执行两个“线程“，我们的计算没有吞吐量限制的 关键路径。

## The General Case 通用例子

如果一个指令有 延迟 `x` 和吞吐量 `y`,那你需要使用  $x \cdot y$  个累加器来使其饱和。这也意味着你需要花费  $x \cdot y$ 个逻辑寄存器来保存它们的值，这是CPU设计的一个重要考虑例子，限制了高延迟指令的最大可用执行单元数。

此技术主要用于 SIMD，而不是标量代码。您可以泛化上面的代码，并比编译器更快地计算总和和其他约简。


在优化循环时，通常只有一个或几个执行端口，您希望充分利用它们，并且围绕它们设计循环的其余部分。由于不同的指令可能使用不同的端口集，因此并不总是清楚哪个端口会被过度使用。在这种情况下，机器代码分析器对于查找小型装配循环的瓶颈非常有帮助。

