
从编译器获得高性能的第一步是要求它优化，这是通过一百多种不同的编译器选项、属性和编译指示来完成的。

## 优化等级

GCC中的优化有四个半 主要级别：

- `-O0` 默认，不执行任何优化 (不过它的确优化了编译速度).
- `-O1` (别名 `-O`) 执行一些唾手可得的优化，几乎不影响编译时间.
- `-O2` 启用所有已知 几乎无负面效果 而且可以在合理时间内编译的优化(这是大部分项目生产环境使用的).
- `-O3` 采用非常激进的优化, 启用几乎所有在GCC中实现的 *正确* 优化.
- `-Ofast` 执行所有 `-O3`操作,外加一部分可能违反严格合规性标准的优化标志, 但对大部分应用来说不重要的 (e.g., 浮点运算可能会重新排列，造成结果在尾数中偏差几位).

还有许多其他标志甚至 不在`-Ofast`中，因为它们非常情景化，默认启用更有可能损害性能。我们将在下一小节讨论部分

## Specifying Targets 指定目标

你可能要做的下一件事 是 告诉编译器 更多关于运行此代码的计算机的信息：平台集越小越好。默认情况下，会生成在在任何相对较新的 （>2000） x86 CPU 上运行的二进制文件。缩小范围的最简单方式是 使用 `-march` 值得具体的微体系结构：`-march=haswell`。如果在将运行二进制文件的同一台计算机上进行编译，则可以用于 `-march=native` 自动检测。

指令集通常是向后兼容的，因此你只需要指定你需要支持的最老版本。一个更 鲁棒的方式是 列出来 CPU保证支持的特性： `-mavx2`, `-mpopcnt`。当您只想为特定机器调整程序而不使用任何可能在不兼容的 CPU 上导致崩溃的指令时，你可以使用`-mtune` 标志（`-march=x` 默认也使用 `-mtune=x`）

这些选项也可以在代码里使用 pragmas

```c++
#pragma GCC optimize("O3")
#pragma GCC target("avx2")
```

但你需要优化一个 单独的高性能步骤 时，这样是有用的，不用忍受整个项目的编译时间增加
## Multiversioned Functions 多版本函数

有些时候你想要在一个单独的库里面提供多种体系结构相关实现时，你可以使用attribute 语法来在编译期从多版本函数中自动选择：

```c++
__attribute__(( target("default") )) // fallback implementation
int popcnt(int x) {
    int s = 0;
    for (int i = 0; i < 32; i++)
        s += (x>>i&1);
    return s;
}

__attribute__(( target("popcnt") )) // used if popcnt flag is enabled
int popcnt(int x) {
    return __builtin_popcount(x);
}
```

在 Clang 中，不能使用pragma从源代码中设置目标和优化标志，但可以像在 GCC 中一样attributes。