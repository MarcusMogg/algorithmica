
如果你从头开始按顺序阅读本章，你可能想知道：为什么我要在浮点数之后引入整数算术？不是应该更容易吗？

True：纯整数表示更简单。但是，与直觉相反，它们的简单性允许用其他操作来表达更多的可能性。如果浮点表示是如此笨拙，以至于它们的大部分操作都是在硬件中实现的，那么有效地操作整数需要对指令集进行更具创造性的使用。

## 二进制格式

无符号整数只是用二进制写的自然数：

$$
\begin{aligned}
   5_{10}   &= 101_2 = 4 + 1
\\ 42_{10}  &= 101010_2 = 32 + 8 + 2
\\ 256_{10} &= 100000000_2 = 2^8
\end{aligned}
$$

当运算的结果无法适应字大小时（例如，大于或等于 32 位无符号整数  $2^{32}$  ），会发生 溢出 *overflows* ，只留下结果的最低 32 位。 类似的，如果结果为负数，结果将增加到  $2^{32}$ ，向下溢出*underflows*。 所以始终保持在  $[0, 2^{32})$ 范围内。

这相当于以 2 的幂模执行所有操作：

$$
\begin{aligned}
    256                 &\equiv 0 \pmod {2^8}
\\  2021                &\equiv 229 \pmod {2^8}
\\  -42 \equiv 256 - 42 &\equiv 214 \pmod {2^8}
\end{aligned}
$$

在任何一种情况下，它都会设置一个特殊的标志（寄存器），您可以检查该标志。但通常当人们显式使用无符号整数时，他们期望这种行为（溢出）。

## 有符号整数

有符号整数支持存储负值，方法是将最高位专用于表示 数字的符号，其方式与浮点数类似。这使得可表示的非负数的范围减半：最大可能的 32 位整数是$(2^{31}-1)$  而不是 $(2^{32}-1)$. 但是负值的编码与浮点数的编码并不完全相同。

计算机工程师甚至比程序员更懒惰——这不仅是出于对简化的本能渴望，也是为了节省晶体管空间。这可以通过重用已经用于其他操作的电路来实现，这就是他们在设计有符号整数格式时的目标：

- 对于 n-bit 有符号整数类型， $[0, 2^{n-1})$  范围内所有数字的编码与其无符号二进制表示形式相同。
- $[-2^{n-1}, 0)$ 范围内的所有数字都紧跟在“正”范围之后按顺序编码。即， 起始值 $(-2^{n - 1})$  编码等于 $(2^{n-1})$，结束于 $(-1)$编码等于 $(2^{n} -1)$

看待这个问题的一种方法是，所有负数都被编码，就好像它们从$2^n$  减去一样  —— 这种操作称为 2 的补码：

$$
\begin{aligned}
-x &= 2^{32} - x
\\ &= \bar{x} + 1
\end{aligned}
$$

这里 $\bar{x}$ 表示按位否, 也可以认为是 $(2^n - 1) - x$.

作为练习，以下是有关有符号整数的一些事实：

- 所有正数和零与其二进制表示法相同。
- 所有负数最高位都为0.
- 可表示的负数比正数多一个，因为0.
- 对于 `int`,  $(2^{31}-1) + 1$, 结果为 $-2^{31}$, 表示为 `10000000` (出于说明目的，我们只写8位而不是32位).
- 对于正数 `x`, 你可以使用 `~x + 1`得到 `-x` 的表示.
- `-1` 可以表示为 `~1 + 1 = 11111110 + 00000001 = 11111111`.
- `-42` 可以表示为 `~42 + 1 = 11010101 + 00000001 = 11010110`.
-  `-1 = 11111111` 后跟 `0 = -1 + 1 = 11111111 + 00000001 = 00000000`.


这种编码的主要优点是，您无需执行任何操作即可将无符号整数转换为有符号整数（除了检查溢出），并且您可以在大多数操作中重复使用相同的电路，可能只需要翻转符号位进行比较。


也就是说，需要小心有符号整数溢出。尽管它们几乎总是以与无符号整数相同的方式溢出，但编程语言通常将溢出的可能性视为未定义的行为。如果您需要溢出整数变量，请将它们转换为无符号整数：无论如何它都是免费的。

**Exercise.** What is the only integer value for which `std::abs` produces a wrong result? What will this result be?  $-2^{31}$

## Integer Types

整数有不同的大小，但功能大致相同。

| Bits | Bytes | Signed C type        | Unsigned C type      | Assembly |
|-----:|-------|----------------------|----------------------|----------|
|    8 | 1     | `signed char`| `unsigned char`      | `byte`   |
|   16 | 2     | `short`              | `unsigned short`     | `word`   |
|   32 | 4     | `int`                | `unsigned int`       | `dword`  |
|   64 | 8     | `long long`          | `unsigned long long` | `qword`  |



整数的位只是按顺序存储。这里唯一的歧义是存储它们的顺序 - 从左到右或从右到左 - 称为字节序。根据体系结构，格式可以是：

- 小端序，首先列出较低的位。
- 大端序，首先列出更高的位。本文前面的所有示例都遵循它。


这似乎是一个重要的架构方面，但在大多数情况下，它并没有区别：只需选择一种风格并坚持下去。但在某些情况下，它确实有影响：

- 小端的优点是 可以通过加载更少的字节将值转换为较小的类型(e.g., `long long` to `int`), 这在大多数情况下意味着什么都不做 — 由于寄存器别名，, `eax` 指向 `rax`的前4个字节, 因此转换基本上是免费的. 读取各种类型大小的值也更容易 — 在大端结构上, 从 `long long` 数组 读一个int 需要 指针移动2字节.
- 大端序的优点是先加载较高的字节，理论上可以使比较和打印等从高到低的例程更快。您还可以执行某些检查，例如仅通过加载数字的第一个字节来确定数字是否为负数。 还有网络传输，可以先读高bit

大端序也更“自然”——这就是我们在纸上写二进制数的方式——但更快的类型转换的优势超过了它。出于这个原因，大多数硬件默认使用小端序，尽管某些 CPU 是“双端”并且可以配置为按需切换模式。

## 128-bit Integers

有时我们需要将两个 64 位整数相乘得到一个 128 位整数——通常用作临时值并立即将模化为 64 位整数。

没有 128 位寄存器来保存这种乘法的结果，因此 `mul` 指令除了将寄存器中的值相乘并保留结果的下半部分的正常 `mul r r` 形式外，还有另一种 `mul r` 模式，它将 `rax` 寄存器中存储的任何内容乘以其操作数，并将结果写入两个寄存器 — 结果的较低 64 位将进入 `rax` ， 较高的 64 位进入 `rdx` ：

```nasm
; input: 64-bit integers a and b, stored in rsi and rdi
; output: 128-bit product a * b, stored in rax (lower 64-bit) and rdx (higher 64-bit)
mov     rax, rdi
mov     r8, rdx
imul    rsi
```

某些编译器具有支持此操作的单独类型。在GCC和Clang中，可用： `__int128`
```cpp
void prod(int64_t a, int64_t b, __int128 *c) {
    *c = a * (__int128) b;
}
```

它的典型用例是立即提取乘法的较低或较高部分并忽略它：

```c++
__int128_t x = 1;
int64_t hi = x >> 64;
int64_t lo = (int64_t) x; // will be just truncated
```

对于乘法以外，128 位整数只是捆绑为两个寄存器。这使得拥有成熟的 128 位类型太奇怪了，因此除了基本的算术运算之外，对它的支持是有限的。例如：

```c++
__int128_t add(__int128_t a, __int128_t b) {
    return a + b;
}
```

编译成：

```nasm
add:
    mov rax, rdi
    add rax, rdx    ; this sets the carry flag in case of an overflow
    adc rsi, rcx    ; +1 if the carry flag is set
    mov rdx, rsi
    ret
```

其他平台提供了类似的机制来处理长于word的乘法。例如，Arm 具有 `mullo` 指令，返回乘法的较低和较高部分，x86 SIMD 扩展具有 `mulhi` 类似的 32 位指令。
